
# ПРАКТИКА

## Практика-1 Введение в pl

### 1.1

1. Измените функцию book_name так, чтобы длина возвращаемого значения не превышала 45 символов.

Если название книги при этом обрезается, оно должно завершаться на троеточие. 

Проверьте реализацию в SQL и в приложении;при необходимости добавьте книг с длинными названиями.

2. Снова измените функцию book_name так, чтобы избыточно длинное название уменьшалось на целое слово. Проверьте реализацию


### 1.2*

1. Напишите PL/pgSQL-функцию, которая возвращает строку заданной длины из случайных символов.

2. Задача про игру в «наперстки».В одном из трех наперстков спрятан выигрыш.Игрок выбирает один из этих трех. Ведущий убирает один из двух оставшихся наперстков (обязательно пустой) и дает игроку возможность поменять решение, то есть выбрать второй из двух оставшихся.

Есть ли смысл игроку менять выбор или нет смысла менять первоначальный вариант?

Задание: используя PL/pgSQL, посчитайте вероятность выигрыша и для начального выбора, и для измененного.

## Практика-2

### 2.1

1. Напишите функцию add_author для добавления новых авторов. Функция должна принимать три параметра (фамилия, имя, отчество) и возвращать идентификатор нового автора. 

Проверьте, что приложение позволяет добавлять авторов.

2. Напишите функцию buy_book для покупки книги. Функция принимает идентификатор книги и уменьшает количество таких книг на складе на единицу. Возвращаемое значение отсутствует. 

Проверьте, что в «Магазине» появилась возможность покупки книг

### 2.2*
Напишите игру, в которой сервер пытается угадать загаданное пользователем животное, задавая последовательные уточняющие вопросы, на которые можно отвечать «да» или «нет».Если сервер предложил неправильный вариант, он запрашивает у пользователя имя животного и отличающий вопрос. Эта новая информация запоминается и используется в следующих играх.

1. Создайте таблицу для представления информации.

2. Придумайте интерфейс и реализуйте необходимые функции.

3. Проверьте реализацию.


```
Пример диалога (между людьми):

— Это млекопитающее? — Да.

— Это слон? — Нет.

— Сдаюсь. Кто это? — Кит.

— Как отличить кита от слона? — Он живет в воде.

1. Информацию удобно представить в виде двоичного дерева. Внутренние узлы хранят вопросы, листовые узлы — названия животных. Один из дочерних узлов соответствует ответу «да», другой — ответу «нет».

2. Между вызовами функций надо передавать информацию о том, на каком узле дерева мы остановились («контекст» диалога). Функции могут быть, например, такими:

- начать игру (нет входного контекста) 

FUNCTION start_game(OUT context integer, OUT question text)

- продолжение игры (получаем ответ, выдаем следующий вопрос) 

FUNCTION continue_game(    INOUT context integer, IN answer boolean,    OUT you_win boolean, OUT question text)

- завершение игры (внесение информации о новом животном) 

FUNCTION end_game(    IN context integer, IN name text, IN question text)RETURNS void

```

## Практика-3

### 3.1

1. Измените функцию book_name: если у книги больше двух авторов, то в названии указываются только первые два и в конце добавляется «и др.». 

Проверьте работу функции в SQL и в приложении.

2. Попробуйте написать функцию book_name на SQL.

Какой вариант нравится больше — PL/pgSQL или SQL?


### 3.2*

1. Требуется распределить расходы на электроэнергиюпо отделам компании пропорционально количеству сотрудников (перечень отделов находится в таблице).

Напишите функцию, которая примет общую сумму расходов и запишет распределенные расходы в строки таблицы.

Числа округляются до копеек; сумма расходов всех отделов должна в точности совпадать с общей суммой.

2. Напишите табличную функцию, имитирующую сортировку слиянием. Функция принимает две курсорные переменные; оба курсора уже открыты и возвращают упорядоченные по неубыванию целые числа. Требуется выдать общую упорядоченную последовательность чисел из обоих источников.


## Практика-4

1. Измените функцию get_catalog так, чтобы запроск представлению catalog_v формировался динамическии содержал условия только на те поля, которые заполненына форме поиска в «Магазине». 

Убедитесь, что реализация не допускает возможности внедрения SQL-кода. 

Проверьте работу функции в приложении

2. Создайте функцию, которая возвращает строки матричного отчета по функциям в базе данных. 

Столбцы должны содержать имена владельцев функций,строки — названия схем, а ячейки — количество функций данного владельца в данной схеме. 

Как можно вызвать такую функцию?


## Практика-5

### 5.1
1. Создайте функцию add_book для добавления новой книги. 

Функция должна принимать два параметра — название книги и массив идентификаторов авторов —и возвращать идентификатор новой книги. 

Проверьте, что в приложении появилась возможность добавлять книги.

### 5.2*

1. Реализуйте функцию map, принимающую два параметра:массив вещественных чисел и название вспомогательной функции, принимающей один параметр вещественного типа. Функция возвращает массив, полученный из исходного применением вспомогательной функции к каждому элементу.

2. Реализуйте функцию reduce, принимающую два параметра:массив вещественных чисел и название вспомогательной функции, принимающей два параметра вещественного типа. Функция возвращает вещественное число, полученное последовательной сверткой массива слева направо.

3. Сделайте функции map и reduce полиморфными

```
1. Например:map(ARRAY[4.0,9.0],'sqrt') → ARRAY[2.0,3.0]

2. Например:reduce(ARRAY[1.0,3.0,2.0,0.5],'greatest') → 3.0

В этом случае значение вычисляется какgreatest( greatest( greatest(1.0,3.0), 2.0 ), 0.5 )

```




## Практика-6 Исключения

### 6.1

1. Если при добавлении новой книги указать одного и того же автора несколько раз, произойдет ошибка.

Измените функцию add_book: перехватите ошибку нарушения уникальности и вместо нее вызовите ошибкус понятным текстовым сообщением. 

Проверьте изменения в приложении.

### 6.2

1. Ряд языков имеет конструкцию try … catch … finally …,в которой try соответствует BEGIN, catch — EXCEPTION,а операторы из блока finally срабатывают всегда, независимо от того, возникло ли исключение и было ли оно обработано блоком catch. Предложите способ добиться подобного эффекта в PL/pgSQL.

2. Сравните стеки вызовов, получаемые конструкциями GET STACKED DIAGNOSTICS с элементом pg_exception_contextи GET [CURRENT] DIAGNOSTICS с элементом pg_context.

3. Напишите функцию getstack, возвращающую текущий стек вызовов в виде массива строк. Сама функция getstack не должна фигурировать в стеке